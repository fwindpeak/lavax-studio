# LavaX (.lav) 文件格式与指令集全手册 (V3.0)

本文档是基于 LavaX 编译器源码及核心资料整理的终极技术参考。旨在覆盖 LavaX 虚拟机（GVM）的所有指令、内存布局与文件结构。**所有指令表均已严格按 16 进制操作码（Opcode）升序排列**，专为解析器/编译器开发设计。

---

## 1. 文件结构 (File Structure)

LavaX 文件由 **16字节文件头** + **初始化指令** + **程序指令流** 组成。

### 1.1 文件头 (16 Bytes Header)

| 偏移 | 大小 | 说明 | 编译器关联 |
| :--- | :--- | :--- | :--- |
| `0x00` | 3 | 魔数: `0x4C 0x41 0x56` ('LAV') | `strcpy(FB_CUSH, "LAV")` |
| `0x03` | 1 | 版本号: `0x12` (18) | `*(FB_CUSH + 3) = 18` |
| `0x04` | 1 | 填充: `0x00` | - |
| `0x05` | 1 | 内存限制标记 (`0x74` 或 `0x80`) | 决定运行该程序机型内存校验门槛 |
| `0x06` | 2 | 数组初始化空间 (Little-Endian) | `#loadall` 机制专用 |
| `0x08` | 2 | 变量总空间入口地址 (`jp_var`) | 指向代码中写入变量总空间的位置 |
| `0x0B` | 4 | 填充: `0x00` | - |
| `0x0F` | 1 | 填充: `0x00` | - |

---

## 2. 基础指令集 (Base Instructions: 0x01 - 0x7F)

该部分为虚拟机的核心指令流，涵盖数据加载、算术逻辑、控制流等。**已按 HEX 升序严格排列。**

| HEX | DEC | 助记符 | 操作数 | 分类 | 详细描述与语义 |
| :---: | :---: | :--- | :--- | :--- | :--- |
| **`0x01`** | 1 | **PUSH_B** | `u8` | 数据推送 | 压入 1 字节并补零为 4 字节 (`push3B #$000000`) |
| **`0x02`** | 2 | **PUSH_W** | `i16` | 数据推送 | 压入 2 字节并补零为 4 字节 (`push2B #$0000`) |
| **`0x03`** | 3 | **PUSH_D** | `i32` | 数据推送 | 压入 4 字节小端序整数 |
| **`0x04`** | 4 | **LD_G_B** | `u16` | 全局寻址 | 加载全局 1 字节 (`char`) 到栈 |
| **`0x05`** | 5 | **LD_G_W** | `u16` | 全局寻址 | 加载全局 2 字节 (`int`) 到栈 |
| **`0x06`** | 6 | **LD_G_D** | `u16` | 全局寻址 | 加载全局 4 字节 (`long`) 到栈 |
| **`0x07`** | 7 | **LD_G_O_B**| `u16` | 全局寻址 | 全局数组 1 字节: `addr = (u16 + pop4B); push([addr])` |
| **`0x08`** | 8 | **LD_G_O_W**| `u16` | 全局寻址 | 全局数组 2 字节: `addr = (u16 + pop4B); push([addr])` |
| **`0x09`** | 9 | **LD_G_O_D**| `u16` | 全局寻址 | 全局数组 4 字节: `addr = (u16 + pop4B); push([addr])` |
| **`0x0A`** | 10 | **LEA_G_B**| `u16` | 全局寻址 | 全局数组头 1: `push(u16 + pop2B \| $0100)` |
| **`0x0B`** | 11 | **LEA_G_W**| `u16` | 全局寻址 | 全局数组头 2: `push(u16 + pop2B \| $0200)` |
| **`0x0C`** | 12 | **LEA_G_D**| `u16` | 全局寻址 | 全局数组头 4: `push(u16 + pop2B \| $0400)` |
| **`0x0D`** | 13 | **PUSH_STR**| `str\0` | 数据推送 | 压入内嵌字符串地址。受 `strMask` 遮罩影响，读取时异或解密。 |
| **`0x0E`** | 14 | **LD_L_B** | `i16` | 局部寻址 | 加载局部 1 字节: `addr = (i16 + BASE); push([addr])` |
| **`0x0F`** | 15 | **LD_L_W** | `i16` | 局部寻址 | 加载局部 2 字节: `addr = (i16 + BASE); push([addr])` |
| **`0x10`** | 16 | **LD_L_D** | `i16` | 局部寻址 | 加载局部 4 字节: `addr = (i16 + BASE); push([addr])` |
| **`0x11`** | 17 | **LD_L_O_B**| `i16` | 局部寻址 | 局部数组访问 (1B): `a[0][0]` |
| **`0x12`** | 18 | **LD_L_O_W**| `i16` | 局部寻址 | 局部数组访问 (2B): `b[0][0]` |
| **`0x13`** | 19 | **LD_L_O_D**| `i16` | 局部寻址 | 局部数组访问 (4B): `c[0][0]` |
| **`0x14`** | 20 | **LEA_L_B**| `i16` | 局部寻址 | 局部数组头 1: `push($8100)` (相对 BASE 偏移后压入标识) |
| **`0x15`** | 21 | **LEA_L_W**| `i16` | 局部寻址 | 局部数组头 2: `push($8200)` |
| **`0x16`** | 22 | **LEA_L_D**| `i16` | 局部寻址 | 局部数组头 4: `push($8400)` |
| **`0x17`** | 23 | **LEA_OFT** | `u16` | 局部寻址 | 地址计算: `push(pop4B + 0x0000u16)` |
| **`0x18`** | 24 | **LEA_L_PH**| `u16` | 局部寻址 | 局部数组 `a[0]` 寻址 |
| **`0x19`** | 25 | **LEA_ABS** | `u16` | 全局寻址 | 压入绝对地址的 4 字节数据 |
| **`0x1A`** | 26 | **LD_TEXT** | - | 内存寻址 | 压入文字缓存区 (`_TEXT`) 地址 |
| **`0x1B`** | 27 | **LD_GRAP** | - | 内存寻址 | 压入显存数据区 (`_GRAPH`) 地址 |
| **`0x1C`** | 28 | **NEG** | - | 算术逻辑 | 符号取反 `-a` |
| **`0x1D`** | 29 | **INC_PRE** | - | 算术逻辑 | 前置 `++x`: `push x; inc x` |
| **`0x1E`** | 30 | **DEC_PRE** | - | 算术逻辑 | 前置 `--x` |
| **`0x1F`** | 31 | **INC_POS** | - | 算术逻辑 | 后置 `x++`: `inc x; push x` |
| **`0x20`** | 32 | **DEC_POS** | - | 算术逻辑 | 后置 `x--` |
| **`0x21`** | 33 | **ADD** | - | 算术逻辑 | 加法: `push(pop4B + pop4B)` |
| **`0x22`** | 34 | **SUB** | - | 算术逻辑 | 减法: `push(-pop4B + pop4B)` |
| **`0x23`** | 35 | **AND** | - | 算术逻辑 | 按位与 `&` |
| **`0x24`** | 36 | **OR** | - | 算术逻辑 | 按位或 `\|` |
| **`0x25`** | 37 | **NOT** | - | 算术逻辑 | 按位取反 `~` |
| **`0x26`** | 38 | **XOR** | - | 算术逻辑 | 按位异或 `^` |
| **`0x27`** | 39 | **L_AND** | - | 算术逻辑 | 逻辑与 `&&` |
| **`0x28`** | 40 | **L_OR** | - | 算术逻辑 | 逻辑或 `\|\|` |
| **`0x29`** | 41 | **L_NOT** | - | 算术逻辑 | 逻辑非 `!` |
| **`0x2A`** | 42 | **MUL** | - | 算术逻辑 | 乘法 `*` |
| **`0x2B`** | 43 | **DIV** | - | 算术逻辑 | 除法: `push(1 / (pop4B / pop4B))` |
| **`0x2C`** | 44 | **MOD** | - | 算术逻辑 | 取模 `%` |
| **`0x2D`** | 45 | **SHL** | - | 算术逻辑 | 左移 `<<` |
| **`0x2E`** | 46 | **SHR** | - | 算术逻辑 | 右移 `>>` |
| **`0x2F`** | 47 | **EQ** | - | 算术逻辑 | 等于 `==` |
| **`0x30`** | 48 | **NEQ** | - | 算术逻辑 | 不等于 `!=` |
| **`0x31`** | 49 | **LE** | - | 算术逻辑 | 小于等于 `<=` |
| **`0x32`** | 50 | **GE** | - | 算术逻辑 | 大于等于 `>=` |
| **`0x33`** | 51 | **GT** | - | 算术逻辑 | 大于 `>` |
| **`0x34`** | 52 | **LT** | - | 算术逻辑 | 小于 `<` |
| **`0x35`** | 53 | **STORE** | - | 算术逻辑 | 赋值 (堆栈寻址赋值运算) |
| **`0x36`** | 54 | **LD_IND** | - | 算术逻辑 | 间接加载 (将栈顶地址内容压栈) |
| **`0x38`** | 56 | **POP** | - | 数据操作 | 弹出栈顶并丢弃 |
| **`0x39`** | 57 | **JZ** | `u24` | 流程控制 | **IF FALSE GOTO**: 栈顶为0则跳转到绝对文件偏移 |
| **`0x3B`** | 59 | **JMP** | `u24` | 流程控制 | **GOTO**: 无条件跳转到绝对文件偏移 |
| **`0x3C`** | 60 | **SPACE** | `u16` | 流程控制 | **START POINT**: 程序入口起点标记，紧跟 header |
| **`0x3D`** | 61 | **CALL** | `u24` | 流程控制 | **CALL**: 跳转到指定文件偏移 (保存 EIP, EBP) |
| **`0x3E`** | 62 | **FUNC** | `u24` | 流程控制 | **FUNC DEF**: `u16`代码偏移 + `u8`参数个数 |
| **`0x3F`** | 63 | **RET** | - | 流程控制 | **RTS**: 子程序返回 |
| **`0x40`** | 64 | **EXIT** | - | 流程控制 | **END**: 彻底结束程序 |
| **`0x41`** | 65 | **INIT** | 变长 | 流程控制 | 复合数据初始化: 2B地址+2B长度+数据 |
| **`0x42`** | 66 | **LD_GBUF** | - | 内存寻址 | 压入绘图缓冲区 (`_GBUF`) 地址 |
| **`0x43`** | 67 | **MASK** | `u8` | 编译特殊 | 设置 `strMask` 遮罩，用于 `0x0D` 字符串加解密 |
| **`0x44`** | 68 | **LOADALL** | - | 编译特殊 | `#loadall` 全局加载标记 |
| **`0x45`** | 69 | **ADD_C** | `i16` | 立即内联 | `push(pop4B + i16)` |
| **`0x46`** | 70 | **SUB_C** | `i16` | 立即内联 | `push(pop4B - i16)` |
| **`0x47`** | 71 | **MUL_C** | `i16` | 立即内联 | `push(pop4B * i16)` |
| **`0x48`** | 72 | **DIV_C** | `i16` | 立即内联 | `push(pop4B / i16)` |
| **`0x49`** | 73 | **MOD_C** | `i16` | 立即内联 | `push(pop4B % i16)` |
| **`0x4A`** | 74 | **SHL_C** | `i16` | 立即内联 | `push(pop4B << i16)` |
| **`0x4B`** | 75 | **SHR_C** | `i16` | 立即内联 | `push(pop4B >> i16)` |
| **`0x4C`** | 76 | **EQ_C** | `i16` | 立即内联 | `push(pop4B == i16)` |
| **`0x4D`** | 77 | **NEQ_C** | `i16` | 立即内联 | `push(pop4B != i16)` |
| **`0x4E`** | 78 | **GT_C** | `i16` | 立即内联 | `push(pop4B > i16)` |
| **`0x4F`** | 79 | **LT_C** | `i16` | 立即内联 | `push(pop4B < i16)` |
| **`0x50`** | 80 | **GE_C** | `i16` | 立即内联 | `push(pop4B >= i16)` |
| **`0x51`** | 81 | **LE_C** | `i16` | 立即内联 | `push(pop4B <= i16)` |

---

## 3. 系统函数调用 (System Syscalls: 0x80 - 0xDF)

标准库函数直接映射为操作码 `0x80` 到 `0xDF`（DEC: 128 - 223）。为了解析器构建的安全性，已将其转换为单列表格，并**严格按 HEX 升序排列**。

> **注关于 `0xAD`**：在运行时 `0xAD` 为 `memcpy`。但在编译器构建期间，`0xAD` 常被用作 `F_FLAG`（函数指针链接占位标记）。解析器应根据上下文环境（静态解析 vs 运行执行）区分。

| HEX | DEC | 参数量 | 返回值 | 函数名 (系统调用) |
| :---: | :---: | :---: | :---: | :--- |
| **`0x80`** | 128 | 1 | 0 | `putchar` |
| **`0x81`** | 129 | 0 | 1 | `getchar` |
| **`0x82`** | 130 | 0 | 0 | `printf` |
| **`0x83`** | 131 | 2 | 0 | `strcpy` |
| **`0x84`** | 132 | 1 | 1 | `strlen` |
| **`0x85`** | 133 | 1 | 0 | `SetScreen` |
| **`0x86`** | 134 | 1 | 0 | `UpdateLCD` |
| **`0x87`** | 135 | 2 | 0 | `Delay` |
| **`0x88`** | 136 | 6 | 0 | `WriteBlock` |
| **`0x89`** | 137 | 0 | 0 | `Refresh` |
| **`0x8A`** | 138 | 4 | 0 | `TextOut` |
| **`0x8B`** | 139 | 5 | 0 | `Block` |
| **`0x8C`** | 140 | 5 | 0 | `Rectangle` |
| **`0x8D`** | 141 | 1 | 0 | `exit` |
| **`0x8E`** | 142 | 0 | 0 | `ClearScreen` |
| **`0x8F`** | 143 | 1 | 1 | `abs` |
| **`0x90`** | 144 | 0 | 1 | `rand` |
| **`0x91`** | 145 | 1 | 0 | `srand` |
| **`0x92`** | 146 | 2 | 0 | `Locate` |
| **`0x93`** | 147 | 0 | 1 | `Inkey` |
| **`0x94`** | 148 | 3 | 0 | `Point` |
| **`0x95`** | 149 | 2 | 1 | `GetPoint` |
| **`0x96`** | 150 | 5 | 0 | `Line` |
| **`0x97`** | 151 | 6 | 0 | `Box` |
| **`0x98`** | 152 | 5 | 0 | `Circle` |
| **`0x99`** | 153 | 6 | 0 | `Ellipse` |
| **`0x9A`** | 154 | 0 | 0 | `Beep` |
| **`0x9B`** | 155 | 1 | 1 | `isalnum` |
| **`0x9C`** | 156 | 1 | 1 | `isalpha` |
| **`0x9D`** | 157 | 1 | 1 | `iscntrl` |
| **`0x9E`** | 158 | 1 | 1 | `isdigit` |
| **`0x9F`** | 159 | 1 | 1 | `isgraph` |
| **`0xA0`** | 160 | 1 | 1 | `islower` |
| **`0xA1`** | 161 | 1 | 1 | `isprint` |
| **`0xA2`** | 162 | 1 | 1 | `ispunct` |
| **`0xA3`** | 163 | 1 | 1 | `isspace` |
| **`0xA4`** | 164 | 1 | 1 | `isupper` |
| **`0xA5`** | 165 | 1 | 1 | `isxdigit` |
| **`0xA6`** | 166 | 2 | 0 | `strcat` |
| **`0xA7`** | 167 | 2 | 1 | `strchr` |
| **`0xA8`** | 168 | 2 | 1 | `strcmp` |
| **`0xA9`** | 169 | 2 | 1 | `strstr` |
| **`0xAA`** | 170 | 1 | 1 | `tolower` |
| **`0xAB`** | 171 | 1 | 1 | `toupper` |
| **`0xAC`** | 172 | 3 | 0 | `memset` |
| **`0xAD`** | 173 | 3 | 0 | `memcpy` *(编译期占位用作 F_FLAG)* |
| **`0xAE`** | 174 | 2 | 1 | `fopen` |
| **`0xAF`** | 175 | 1 | 0 | `fclose` |
| **`0xB0`** | 176 | 4 | 1 | `fread` |
| **`0xB1`** | 177 | 4 | 1 | `fwrite` |
| **`0xB2`** | 178 | 3 | 1 | `fseek` |
| **`0xB3`** | 179 | 1 | 1 | `ftell` |
| **`0xB4`** | 180 | 1 | 1 | `feof` |
| **`0xB5`** | 181 | 1 | 0 | `rewind` |
| **`0xB6`** | 182 | 1 | 1 | `getc` |
| **`0xB7`** | 183 | 2 | 1 | `putc` |
| **`0xB8`** | 184 | 0 | 0 | `sprintf` |
| **`0xB9`** | 185 | 1 | 1 | `MakeDir` |
| **`0xBA`** | 186 | 1 | 1 | `DeleteFile` |
| **`0xBB`** | 187 | 0 | 1 | `Getms` |
| **`0xBC`** | 188 | 1 | 1 | `CheckKey` |
| **`0xBD`** | 189 | 3 | 0 | `memmove` |
| **`0xBE`** | 190 | 2 | 1 | `Crc16` |
| **`0xBF`** | 191 | 3 | 0 | `Secret` |
| **`0xC0`** | 192 | 1 | 1 | `ChDir` |
| **`0xC1`** | 193 | 1 | 1 | `FileList` |
| **`0xC2`** | 194 | 1 | 0 | `GetTime` |
| **`0xC3`** | 195 | 1 | 0 | `SetTime` |
| **`0xC4`** | 196 | 1 | 1 | `GetWord` |
| **`0xC5`** | 197 | 1 | 0 | `XDraw` |
| **`0xC6`** | 198 | 1 | 0 | `ReleaseKey` |
| **`0xC7`** | 199 | 6 | 0 | `GetBlock` |
| **`0xC8`** | 200 | 1 | 1 | `Sin` |
| **`0xC9`** | 201 | 1 | 1 | `Cos` |
| **`0xCA`** | 202 | 3 | 0 | `FillArea` |
| **`0xCB`** | 203 | 1 | 1 | `PutKey` |
| **`0xCC`** | 204 | 3 | 1 | `FindWord` |
| **`0xCD`** | 205 | 1 | 1 | `PlayInit` |
| **`0xCE`** | 206 | 4 | 1 | `PlayFile` |
| **`0xCF`** | 207 | 0 | 0 | `PlayStops` |
| **`0xD0`** | 208 | 1 | 0 | `SetVolume` |
| **`0xD1`** | 209 | 0 | 0 | `PlaySleep` |
| **`0xD2`** | 210 | 1 | 1 | `opendir` |
| **`0xD3`** | 211 | 1 | 1 | `readdir` |
| **`0xD4`** | 212 | 1 | 0 | `rewinddir` |
| **`0xD5`** | 213 | 1 | 1 | `closedir` |
| **`0xD6`** | 214 | 0 | 0 | `Refresh2` |
| **`0xD7`** | 215 | 0 | 0 | `open_key` |
| **`0xD8`** | 216 | 0 | 0 | `close_key` |
| **`0xD9`** | 217 | 3 | 0 | `PlayWordVoice` |
| **`0xDA`** | 218 | 3 | 0 | `sysexecset` |
| **`0xDB`** | 219 | 1 | 0 | `open_uart` |
| **`0xDC`** | 220 | 0 | 0 | `close_uart` |
| **`0xDD`** | 221 | 1 | 0 | `write_uart` |
| **`0xDE`** | 222 | 0 | 1 | `read_uart` |
| **`0xDF`** | 223 | 0 | 0 | `RefreshIcon` |

---

## 4. LAVA 扩展调用命名空间 (Extended Namespaces)

### 4.1 `0xD3` 命名空间 (System Core)
执行系统级硬件和外设调用。用法: `PUSH [sub_opcode]; CALL_D3`

* `0x00`: **GetPID**
* `0x01`: **SetBrightness**(n)
* `0x02`: **GetBrightness**()
* `0x03..0x05`: **ComOpen**, **ComClose**, **ComWaitReady**
* `0x06..0x08`: **ComSetTimer**, **ComGetc**, **ComPutc**
* `0x09..0x0B`: **ComRead**, **ComWrite**, **ComXor**
* `0x0C..0x0E`: **RamRead**, **DiskReclaim**, **DiskCheck**
* `0x0F`: **FlmDecode**
* `0x10..0x13`: **SndPlay**, **SndOpen**, **SndClose**, **SndIfEnd**
* `0x14`: **PY2GB**(page, spell, word)
* `0x15..0x1A`: **SndPlayFile**, **SndSetVolume**, **SndGetVolume**, **SndStop**, **SndPause**, **SndResume**
* `0x1B`: **Idle**
* `0x1C`: **GetVersion**

### 4.2 `0xD4` 命名空间 (Math Framework)
处理所有浮点运算和高级数学函数。用法: `PUSH [sub_opcode]; CALL_D4`

* `0x00`: 浮点类型转换/返回
* `0x02..0x05`: **fadd**, **fsub**, **fmul**, **fdiv** (浮点运算)
* `0x06`: **f2i** (float to int)
* `0x07..0x09`: **sin**, **cos**, **tan**
* `0x0A..0x0C`: **asin**, **acos**, **atan**
* `0x0D`: **sqrt**
* `0x0E`: **exp**
* `0x0F`: **log**
* `0x10`: **str2f** (string to float)
* `0x11`: **f2str** (float to string)

---

## 5. 运行环境与内存布局

### 5.1 地址映射
GVM 使用统一的物理地址空间：
* `0x0000 - 0x063F`: **VRAM** (160x80 黑白屏幕数据)
* `0x0640 - 0x0C7F`: **GBUF** (绘图缓冲)
* `0x0C80 - 0x0FFF`: **TEXT** (文本显存)
* `0x2000 - ....`: **GLOBAL RAM** (全局变量起始点)

### 5.2 句柄编码 (Handle Encoding)
在执行 `STORE` 或 `INC/DEC` 时，栈顶通常是一个 32 位句柄：
* **低 24 位**: RAM 偏移量。
* **Bits 16-18**: 类型信息 (`0x1`=byte, `0x2`=word, `0x4`=dword)。
* **Bit 23**: 基址标记 (`1` 为局部变量 `ebp+offset`)。

---

## 6. 编译细节与特殊处理

### 6.1 字符串掩码 (strMask)
LavaX 3.0 为了防破解，引入了 `strMask` 机制。
1. 指令 `0x43 [byte]` 设置当前的 `strMask`。
2. 指令 `0x0D` 读取字符串时，会对每个字节进行 `getc() ^ strMask` 操作再存入内存。