# LavaX (.lav) 文件格式与指令集全手册 (V3.0)

本文档是基于 LavaX 编译器源码及核心资料（`GVmaker指令.txt`, `虚拟指令.txt`）整理的终极技术参考。旨在覆盖 LavaX 虚拟机（GVM）的所有指令、内存布局与文件结构。

---

## 1. 文件结构 (File Structure)

LavaX 文件由 **16字节文件头** + **初始化指令** + **程序指令流** 组成。

### 1.1 文件头 (16 Bytes Header)

| 偏移 | 大小 | 说明 | 编译器关联 |
| :--- | :--- | :--- | :--- |
| `0x00` | 3 | 魔数: `0x4C 0x41 0x56` ('LAV') | `strcpy(FB_CUSH, "LAV")` |
| `0x03` | 1 | 版本号: `0x12` (18) | `*(FB_CUSH + 3) = 18` |
| `0x04` | 1 | 填充: `0x00` | - |
| `0x05` | 1 | 内存限制标记 (`0x74` 或 `0x80`) | 决定运行该程序机型内存校验门槛 |
| `0x06` | 2 | 数组初始化空间 (Little-Endian) | `#loadall` 机制专用 |
| `0x08` | 2 | 变量总空间入口地址 (`jp_var`) | 指向代码中写入变量总空间的位置 |
| `0x0B` | 4 | 填充: `0x00` | - |
| `0x0F` | 1 | 填充: `0x00` | - |
---

## 2. 指令集全映射 (Instruction Set)

指令分为 **基础指令** (0x01-0x7F) 和 **系统调用** (0x80-0xFF)。

### 2.1 数据推送与加载 (Data Push & Load)

| HEX | DEC | 助记符 | 操作数 | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| `0x01` | 1 | **PUSH_B** | `u8` | 压入 1 字节整数 |
| `0x02` | 2 | **PUSH_W** | `i16` | 压入 2 字节小端序整数 |
| `0x03` | 3 | **PUSH_D** | `i32` | 压入 4 字节小端序整数 |
| `0x0D` | 13 | **PUSH_STR**| `str\0` | 压入内嵌字符串地址。受 `strMask` 加密影响。 |
| `0x1A` | 26 | **LD_TEXT** | - | 压入文字缓存区 (_TEXT) 地址 |
| `0x1B` | 27 | **LD_GRAP** | - | 压入显存数据区 (_GRAPH) 地址 |
| `0x42` | 66 | **LD_GBUF** | - | 压入绘图缓冲区 (_GBUF) 地址 |

### 2.2 变量访问 (Variable Access)

| HEX | DEC | 助记符 | 操作数 | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| `0x04` | 4 | **LD_G_B** | `u16` | 加载全局 byte 到栈 |
| `0x05` | 5 | **LD_G_W** | `u16` | 加载全局 word (2B) 到栈 |
| `0x06` | 6 | **LD_G_D** | `u16` | 加载全局 dword (4B) 到栈 |
| `0x07` | 7 | **LD_G_O_B**| `u16` | 全局偏移加载: `[base] -> [gd[base+u16]]` (byte) |
| `0x08` | 8 | **LD_G_O_W**| `u16` | 全局偏移加载: `[base] -> [gd[base+u16]]` (word) |
| `0x09` | 9 | **LD_G_O_D**| `u16` | 全局偏移加载: `[base] -> [gd[base+u16]]` (dword) |
| `0x0A` | 10 | **LEA_G_B**| `u16` | 全局 byte 句柄: `[base] -> [base+u16 \| 0x10000]` |
| `0x0B` | 11 | **LEA_G_W**| `u16` | 全局 word 句柄: `[base] -> [base+u16 \| 0x20000]` |
| `0x0C` | 12 | **LEA_G_D**| `u16` | 全局 dword 句柄: `[base] -> [base+u16 \| 0x40000]` |
| `0x0E` | 14 | **LD_L_B** | `i16` | 加载局部 byte 到栈 (相对于 `ebp`) |
| `0x0F` | 15 | **LD_L_W** | `i16` | 加载局部 word 到栈 |
| `0x10` | 16 | **LD_L_D** | `i16` | 加载局部 dword 到栈 |
| `0x11` | 17 | **LD_L_O_B**| `i16` | 局部偏移加载 (byte) |
| `0x12` | 18 | **LD_L_O_W**| `i16` | 局部偏移加载 (word) |
| `0x13` | 19 | **LD_L_O_D**| `i16` | 局部偏移加载 (dword) |
| `0x14` | 20 | **LEA_L_B**| `i16` | 局部 byte 句柄: `[base] -> [base+i16+ebp \| 0x10000]` |
| `0x15` | 21 | **LEA_L_W**| `i16` | 局部 word 句柄 |
| `0x16` | 22 | **LEA_L_D**| `i16` | 局部 dword 句柄 |
| `0x17` | 23 | **LEA_OFT** | `u16` | 将弹出值偏移 u16 后压回 (`LEA` 无类型) |
| `0x18` | 24 | **LEA_L_PH**| `u16` | 计算局部物理地址 |
| `0x19` | 25 | **LEA_ABS** | `u16` | 计算全局绝对物理地址 |

### 2.3 算术与逻辑运算 (Operations)

| HEX | DEC | 助记符 | 描述 |
| :--- | :--- | :--- | :--- |
| `0x1C` | 28 | **NEG** | 符号取反 `-a` |
| `0x1D` | 29 | **INC_PRE** | 前置 `++` (栈顶为地址句柄) |
| `0x1E` | 30 | **DEC_PRE** | 前置 `--` |
| `0x1F` | 31 | **INC_POS** | 后置 `++` |
| `0x20` | 32 | **DEC_POS** | 后置 `--` |
| `0x21` | 33 | **ADD** | 加法 `+` |
| `0x22` | 34 | **SUB** | 减法 `-` |
| `0x23` | 35 | **AND** | 按位与 `&` |
| `0x24` | 36 | **OR** | 按位或 `\|` |
| `0x25` | 37 | **NOT** | 按位取反 `~` |
| `0x26` | 38 | **XOR** | 按位异或 `^` |
| `0x27` | 39 | **L_AND** | 逻辑与 `&&` |
| `0x28` | 40 | **L_OR** | 逻辑或 `\|\|` |
| `0x29` | 41 | **L_NOT** | 逻辑非 `!` |
| `0x2A` | 42 | **MUL** | 乘法 `*` |
| `0x2B` | 43 | **DIV** | 除法 `/` |
| `0x2C` | 44 | **MOD** | 取模 `%` |
| `0x2D` | 45 | **SHL** | 左移 `<<` |
| `0x2E` | 46 | **SHR** | 右移 `>>` |
| `0x2F` | 47 | **EQ** | 等于 `==` |
| `0x30` | 48 | **NEQ** | 不等于 `!=` |
| `0x31` | 49 | **GE** | 大于等于 `>=` |
| `0x32` | 50 | **LE** | 小于等于 `<=` |
| `0x33` | 51 | **GT** | 大于 `>` |
| `0x34` | 52 | **LT** | 小于 `<` |
| `0x35` | 53 | **STORE** | 赋值 (按地址句柄类型写入) |
| `0x36` | 54 | **LD_IND** | 间接加载 (将栈顶地址内容压栈) |
| `0x38` | 56 | **POP** | 弹出栈顶并丢弃 |

### 2.4 流程控制与特殊指令 (Control Flow)

| HEX | DEC | 助记符 | 操作数 | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| `0x39` | 57 | **JZ** | `u24` | 结果为0则跳转 (If False Goto) |
| `0x3B` | 59 | **JMP** | `u24` | 无条件跳转 |
| `0x3C` | 60 | **SPACE** | `u16` | **变量总空间**: 紧跟 header 出现在启动代码中 |
| `0x3D` | 61 | **CALL** | `u24` | 脚本内函数调用 (保存 eip, ebp) |
| `0x3E` | 62 | **FUNC** | `u24` | 函数进入: 1B参数数 + 2B空间。 |
| `0x3F` | 63 | **RET** | - | 子程序返回 |
| `0x40` | 64 | **EXIT** | - | 彻底结束程序 |
| `0x41` | 65 | **INIT** | `u32`+`..`| 复合数据初始化: 2B地址+2B长度+数据 |
| `0x43` | 67 | **MASK** | `u8` | 设置 `strMask` 遮罩，用于字符串解密 |
| `0x44` | 68 | **LOADALL** | - | `#loadall` 全局加载标记 |
| `0xAD` | 173 | **F_FLAG** | - | 函数指针链接占位标记 |

### 2.5 复合优化指令 (Combo Opcodes)

| HEX | DEC | 助记符 | 操作数 | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| `0x45` | 69 | **ADD_C** | `i16` | `pop() + i16` |
| `0x46` | 70 | **SUB_C** | `i16` | `pop() - i16` |
| `0x47` | 71 | **MUL_C** | `i16` | `pop() * i16` |
| `0x48` | 72 | **DIV_C** | `i16` | `pop() / i16` |
| `0x49` | 73 | **MOD_C** | `i16` | `pop() % i16` |
| `0x4A` | 74 | **SHL_C** | `i16` | `pop() << i16` |
| `0x4B` | 75 | **SHR_C** | `i16` | `pop() >> i16` |
| `0x4C` | 76 | **EQ_C** | `i16` | `pop() == i16` |
| `0x4D` | 77 | **NEQ_C** | `i16` | `pop() != i16` |
| `0x4E` | 78 | **GT_C** | `i16` | `pop() > i16` |
| `0x4F` | 79 | **LT_C** | `i16` | `pop() < i16` |
| `0x50` | 80 | **GE_C** | `i16` | `pop() >= i16` |
| `0x51` | 81 | **LE_C** | `i16` | `pop() <= i16` |

---

## 3. 系统函数接口 (System Syscalls)

操作码范围 `0x80 - 0xFF` (即 `128 - 255`)。

### 3.1 核心输入输出
*   `0x80 (128)`: **putchar**(char)
*   `0x81 (129)`: **getchar**()
*   `0x82 (130)`: **printf**(count, args..., fmt)
*   `0x8A (138)`: **TextOut**(mode, str, y, x)
*   `0x8E (142)`: **ClearScreen**()
*   `0x92 (146)`: **Locate**(y, x)

### 3.2 图形绘制
*   `0x88 (136)`: **WriteBlock**(addr, mode, h, w, y, x)
*   `0x89 (137)`: **Refresh**() (将 BUF 内容同步到 VRAM)
*   `0x93 (147)`: **Inkey**() (非阻塞获取按键)
*   `0x94 (148)`: **Point**(mode, y, x)
*   `0x96 (150)`: **Line**(mode, y2, x2, y1, x1)
*   `0x97 (151)`: **Box**(mode, fill, y2, x2, y1, x1)

### 3.3 字符串与内存
*   `0x83 (131)`: **strcpy**(src, dest)
*   `0x84 (132)`: **strlen**(str)
*   `0xAC (172)`: **memset**(val, len, addr)
*   `0xAD (173)`: **memcpy**(len, src, dest)

### 3.4 文件系统
*   `0xAE (174)`: **fopen**(mode, name)
*   `0xAF (175)`: **fclose**(fp)
*   `0xB0 (176)`: **fread**(size, count, buf, fp)
*   `0xB1 (177)`: **fwrite**(size, count, buf, fp)

---

## 4. 运行环境与内存布局

### 4.1 地址映射
GVM 使用统一的物理地址空间：
*   `0x0000 - 0x063F`: **VRAM** (160x80 黑白屏幕数据)
*   `0x0640 - 0x0C7F`: **GBUF** (绘图缓冲)
*   `0x0C80 - 0x0FFF`: **TEXT** (文本显存)
*   `0x2000 - ....`: **GLOBAL RAM** (全局变量起始点)

### 4.2 句柄编码 (Handle Encoding)
在执行 `STORE` 或 `INC/DEC` 时，栈顶通常是一个 32 位句柄：
*   **低 24 位**: RAM 偏移量。
*   **Bits 16-18**: 类型信息 (`0x1`=byte, `0x2`=word, `0x4`=dword)。
*   **Bit 23**: 基址标记 (`1` 为局部变量 `ebp+offset`)。

---

## 5. 编译细节与特殊处理

### 5.1 字符串掩码 (strMask)
LavaX 3.0 为了防破解，引入了 `strMask` 机制。
1. 指令 `0x43 [byte]` 设置当前的 `strMask`。
2. 指令 `0x0D` 读取字符串时，会对每个字节进行 `getc() ^ strMask` 操作再存入内存。

### 5.2 链接库 (.y)
链接库文件本质上是剥离了启动代码和局部定义的 `.lav` 文件，开头记录有其需要的变量空间及函数偏移表。
