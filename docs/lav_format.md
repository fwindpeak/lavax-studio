# LAV 文件格式与虚拟机规范 (GVM)

本文档是为 AI 和开发者设计的完整技术参考手册，旨在提供足够的信息以实现一个功能完备的 LavaX 虚拟机解析器和执行引擎。

### 术语与背景 (History & Terminology)

> [!NOTE]
> 在不同的发展时期和不同的平台上，本项目相关的技术栈有多种称呼：
> *   **Lava / LavaX**: 编程语言名称。
> *   **GVMaker**: 开发环境或 IDE 名称。
> *   **GVM (G VM / GVMaker VM)**: 虚拟机执行引擎。
> 尽管名称不同，但在底层字节码和逻辑架构上，它们通常指代同一套由星星科技 (文曲星) 开发的跨平台执行标准。

---

## 1. 虚拟机架构

GVM 是一个受限制的 32 位环境，主要运行于 16/32 位嵌入式平台。

### 运行时上下文 (Context)
*   **eip (uint24)**: 指令指针，`.lav` 代码流中的字节偏移。
*   **esp (uint16)**: 栈指针，指向 `stk[]` 数组的当前顶部索引。
*   **ebp (uint16)**: 基础指针，指向 `gd[]` 中的当前激活记录（栈帧）基址。
*   **ebp2 (uint16)**: 动态空间指针，用于分配新的栈帧空间及管理临时内存。
*   **fd[] (Uint8Array)**: 加载到内存中的原始程序数据（包含文件头）。
*   **gd[] (Uint8Array)**: 全局数据区（RAM），容量通常为 32KB - 1MB。
*   **stk[] (Int32Array)**: 操作数栈，通常容量为 256-1024 个 `int32`。

### 内存布局 (gd[])
RAM 空间是统一编址的，地址空间通常如下分配：
| 区域名称 | 典型起始地址 | 说明 |
| :--- | :--- | :--- |
| **VRAM** | `0x0000` | 显存 (160x80 monochrome = 1600 bytes) |
| **BUF** | `0x0640` | 绘图缓冲 (160x80) |
| **TEXT** | `0x0C80` | 文字显存 |
| **HEAP** | `0x1000`+ | 动态分配区 / 全局变量 |
| **STR_POOL**| 动态 | 运行时管理的字符串中转区 |

---

## 2. 文件格式

`.lav` 文件由 **16 字节文件头** + **指令流** 组成。

### 文件头 (16 Bytes)
| 偏移 | 大小 | 描述 |
| :--- | :--- | :--- |
| 0x00 | 3 | 魔数: `0x4C 0x41 0x56` ('LAV') |
| 0x03 | 1 | 版本号 (通常为 `0x12`) |
| 0x04 | 4 | 保留 (通常为 0) |
| 0x08 | 1 | 标志字节 (bit 7: 24位地址, bit 4: 32位地址) |
| 0x09 | 1 | 宽度/16 |
| 0x0A | 1 | 高度/16 |
| 0x0B | 5 | 填充 |

**程序入口点**: 紧随文件头之后的 `0x10` 字节偏移处。

---

## 3. 地址处理与对象句柄 (Handle Encoding)

GVM 使用高度编码的 32 位值来表示内存对象句柄。这对于 `STORE` 和 `INC/DEC` 指令至关重要。

### 句柄格式 (Address Handle)
一个 32 位的句柄 `H` 定义如下：
*   **H & 0xFFFFFF**: 基础 RAM 偏移量 (`addr`)。
*   **H & 0x70000**: **数据类型标记 (Bits 16-18)**
    *   `0x10000`: `byte` (char)
    *   `0x20000`: `word` (int, 16-bit)
    *   `0x40000`: `dword` (long/float, 32-bit)
*   **H & 0x800000**: **基址选择器 (Bit 23)**
    *   如果为 1，则实际访问地址为 `ebp + addr`。
    *   如果为 0，则实际访问地址即为 `addr`。

---

## 4. 指令集参考 (基本指令 0x00 - 0x7F)

所有多字节立即数均为 **小端序 (Little-Endian)**。

### 数据推送与加载
| Opcode | 助记符 | 立即数 | 操作数栈 (Before -> After) | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| `0x00` | **NOP** | - | `[...] -> [...]` | 无效操作 |
| `0x01` | **PUSH_B** | `u8` | `[...] -> [..., u8]` | 推 1 字节 |
| `0x02` | **PUSH_W** | `i16` | `[...] -> [..., i16]` | 推 2 字节 |
| `0x03` | **PUSH_D** | `i32` | `[...] -> [..., i32]` | 推 4 字节 |
| `0x04` | **LD_G_B** | `u16` | `[...] -> [..., gd[u16]]` | 加载全局 byte |
| `0x05` | **LD_G_W** | `u16` | `[...] -> [..., *(i16*)&gd[u16]]` | 加载全局 word |
| `0x06` | **LD_G_D** | `u16` | `[...] -> [..., *(i32*)&gd[u16]]` | 加载全局 dword |
| `0x07` | **LD_GO_B**| `u16` | `[..., base] -> [..., gd[base+u16]]` | 全局基址+偏移加载 byte |
| `0x08` | **LD_GO_W**| `u16` | `[..., base] -> [..., gd[base+u16]]` | 全局 word |
| `0x09` | **LD_GO_D**| `u16` | `[..., base] -> [..., gd[base+u16]]` | 全局 dword |
| `0x0a` | **LEA_G_B**| `u16` | `[..., base] -> [..., 0x10000\|(base+u16)]` | 全局 char 句柄 |
| `0x0b` | **LEA_G_W**| `u16` | `[..., base] -> [..., 0x20000\|(base+u16)]` | 全局 int 句柄 |
| `0x0c` | **LEA_G_D**| `u16` | `[..., base] -> [..., 0x40000|(base+u16)]` | 全局 long 句柄 |
| `0x0d` | **STR** | `SZ` str| `[...] -> [..., ram_addr]` | 将内嵌字符串拷贝到 RAM 并压栈 |
| `0x0e` | **LD_L_B** | `i16` | `[...] -> [..., gd[ebp+i16]]` | 加载局部 byte |
| `0x0f` | **LD_L_W** | `i16` | `[...] -> [..., gd[ebp+i16]]` | 加载局部 word |
| `0x10` | **LD_L_D** | `i16` | `[...] -> [..., gd[ebp+i16]]` | 加载局部 dword |
| `0x11` | **LD_LO_B**| `i16` | `[..., base] -> [..., gd[ebp+i16+base]]`| 局部偏移加载 byte |
| `0x12` | **LD_LO_W**| `i16` | `[..., base] -> [..., gd[ebp+i16+base]]`| 局部偏移 word |
| `0x13` | **LD_LO_D**| `i16` | `[..., base] -> [..., gd[ebp+i16+base]]`| 局部偏移 dword |
| `0x14` | **LEA_L_B**| `i16` | `[..., base] -> [..., 0x810000|(i16+base)]`| 计算局部 byte 句柄 |
| `0x15` | **LEA_L_W**| `i16` | `[..., base] -> [..., 0x820000|(i16+base)]`| 计算局部 word 句柄 |
| `0x16` | **LEA_L_D**| `i16` | `[..., base] -> [..., 0x840000|(i16+base)]`| 计算局部 dword 句柄 |
| `0x17` | **LEA_23** | `i16` | `[..., base] -> [..., (i16+base)&0xFFFF]` | 无类型偏移计算 |
| `0x18` | **LEA_24** | `i16` | `[..., base] -> [..., i16+base+ebp]` | 无类型局部物理地址计算 |
| `0x19` | **ADDR_L** | `i16` | `[...] -> [..., i16+ebp]` | 获取局部变量物理地址 (`&var`) |
| `0x1a` | **LD_TBUF**| -     | `[...] -> [..., TBUF_OFFSET]` | 文本缓存地址 |
| `0x1b` | **LD_GRA** | -     | `[...] -> [..., GRAPH_OFFSET]` | 显存地址 |
| `0x42` | **LD_GBUF**| -     | `[...] -> [..., GBUF_OFFSET]` | 缓冲显存地址 |
| `0x35` | **STORE**  | -     | `[..., val, handle] -> [..., val]` | 按句柄类型写入内存 |
| `0x36` | **LD_IND_B**| -     | `[..., addr] -> [..., gd[addr]]` | 直接间接加载 byte |
| `0x52` | **LD_IND_W**| -     | `[..., addr] -> [..., *(i16*)&gd[addr]]` | 直接间接加载 word |
| `0x53` | **LD_IND_D**| -     | `[..., addr] -> [..., *(i32*)&gd[addr]]` | 直接间接加载 dword |
| `0x55` | **TAG_B** | -     | `[..., addr] -> [..., addr|0x10000]` | 添加 byte 类型标记 |
| `0x43` | **LD_R1_B**| `i16` | `[...] -> [..., gd[ebp+i16]]` | 备用局部 byte 加载 |
| `0x44` | **LD_R1_W**| `i16` | `[...] -> [..., *(i16*)&gd[ebp+i16]]` | 备用局部 word/dword 加载 |
| `0x54` | **LEA_R_1**| `i16` | `[..., base] -> [..., base+i16+ebp]` | 备用地址计算 |
| `0x56` | **LEA_R_ADDR**| `i16` | `[...] -> [..., i16+ebp]` | 备用局部地址加载 |
| `0x57` | **POP**    | -     | `[..., a] -> [...]` | 弹出栈顶并丢弃 |

### 运算 (双目运算: result = pop1 op pop2)
| Opcode | 助记符 | 描述 |
| :--- | :--- | :--- |
| `0x1c` | **NEG** | `-a` |
| `0x1d` | **INC_PRE** | 前置 `++` (栈顶为句柄 handle) |
| `0x1e` | **DEC_PRE** | 前置 `--` |
| `0x1f` | **INC_POST**| 后置 `++` |
| `0x20` | **DEC_POST**| 后置 `--` |
| `0x21` | **ADD** | `+` (栈顶依次 pop b, a -> push a+b) |
| `0x22` | **SUB** | `-` |
| `0x23` | **AND** | 按位 `&` |
| `0x24` | **OR** | 按位 `\|` |
| `0x25` | **NOT** | 按位 `~` |
| `0x26` | **XOR** | 按位 `^` |
| `0x27` | **L_AND** | 逻辑 `&&` |
| `0x28` | **L_OR** | 逻辑 `\|\|` |
| `0x29` | **L_NOT** | 逻辑 `!` |
| `0x2a` | **MUL** | `*` |
| `0x2b` | **DIV** | `/` |
| `0x2c` | **MOD** | `%` |
| `0x2d` | **SHL** | `<<` |
| `0x2e` | **SHR** | `>>` |
| `0x2f` | **EQ** | `==` |
| `0x30` | **NEQ** | `!=` |
| `0x31` | **LE** | `<=` |
| `0x32` | **GE** | `>=` |
| `0x33` | **GT** | `>` |
| `0x34` | **LT** | `<` |
| `0x37` | **CAST_PTR**| `(char*)addr` | 栈顶地址强转为 char 指针 |

#### 常量优化指令 (Constant Optimization / Combo Opcodes)
这些指令将 PUSH 立即数与双目运算结合，用于缩短字节码。
所有指令都有一个 **2 字节 (int16)** 立即数操作数 `imm`。
操作流程: `a = pop(); result = a op imm; push(result);`

| Opcode | 助记符 | 操作数 | C 运算等价 |
| :--- | :--- | :--- | :--- |
| `0x45` | **ADD_C** | `i16` | `a + imm` |
| `0x46` | **SUB_C** | `i16` | `a - imm` |
| `0x47` | **MUL_C** | `i16` | `a * imm` |
| `0x48` | **DIV_C** | `i16` | `a / imm` |
| `0x49` | **MOD_C** | `i16` | `a % imm` |
| `0x4a` | **SHL_C** | `i16` | `a << imm` |
| `0x4b` | **SHR_C** | `i16` | `a >> imm` |
| `0x4c` | **EQ_C**  | `i16` | `a == imm` |
| `0x4d` | **NEQ_C** | `i16` | `a != imm` |
| `0x4e` | **GT_C**  | `i16` | `a > imm` |
| `0x4f` | **LT_C**  | `i16` | `a < imm` |
| `0x50` | **GE_C**  | `i16` | `a >= imm` |
| `0x51` | **LE_C**  | `i16` | `a <= imm` |
| `0x54` | **itof**  | -     | `[..., i] -> [..., f]` | 整数转浮点 |
| `0x55` | **ftoi**  | -     | `[..., f] -> [..., i]` | 浮点转整数 |
| `0x56` | **fadd**  | -     | `[..., f2, f1] -> [..., f1+f2]` | 浮点加 |
| `0x57` | **fadd_fi**| -     | `[..., i2, f1] -> [..., f1+i2]` | 浮点+整数 |
| `0x58` | **fadd_if**| -     | `[..., f2, i1] -> [..., i1+f2]` | 整数+浮点 |
| `0x59` | **fsub**  | -     | `[..., f2, f1] -> [..., f1-f2]` | 浮点减 |
| `0x5c` | **fmul**  | -     | `[..., f2, f1] -> [..., f1*f2]` | 浮点乘 |
| `0x5f` | **fdiv**  | -     | `[..., f2, f1] -> [..., f1/f2]` | 浮点除 |
| `0x62` | **fneg**  | -     | `[..., f] -> [..., -f]` | 浮点取负 |
| `0x63` | **flt**   | -     | `[..., f2, f1] -> [..., f1<f2?-1:0]` | 浮点小于比较 |
| `0x64` | **fgt**   | -     | `[..., f2, f1] -> [..., f1>f2?-1:0]` | 浮点大于比较 |
| `0x65` | **feq**   | -     | `[..., f2, f1] -> [..., f1==f2?-1:0]` | 浮点等于比较 |

### 流程控制
| Opcode | 助记符 | 立即数 | 说明 |
| :--- | :--- | :--- | :--- |
| `0x39` | **JZ** | `u24` | 若栈顶为 0 跳转到 `u24` |
| `0x3a` | **JNZ** | `u24` | 若栈顶非 0 跳转到 `u24` |
| `0x3b` | **JMP** | `u24` | 无条件跳转 |
| `0x3c` | **BASE** | `u16` | 设置 `ebp = ebp2 = u16` |
| `0x3d` | **CALL** | `u24` | **具体见下文“函数调用栈帧”** |
| `0x3e` | **FUNC** | `u16`,`u8` | 进入函数。立即数 1: 额外分配内存空间大小; 2: 参数个数 |
| `0x3f` | **RET** | - | 从函数返回 |
| `0x40` | **EXIT** | - | 停止执行并返回 0 |
| `0x41` | **INIT** | `u16`,`u16`| `INIT addr, len`: 后面跟随 `len` 字节数据，拷贝到 `gd[addr]` |
| `0xCF` | **FINISH** | - | 停止 (等同于 EXIT) |
| `0xff` | **EOF** | - | 忽略 |

---

## 5. 函数调用与栈帧 (Calling Convention)

GVM 的函数调用不完全依赖于 `stk[]`，它将关键状态存储在 `gd[]` RAM 中。

### 1. CALL addr (0x3d)
1.  计算返回地址 `ret_eip = eip + 4` (当前指令长度为 4 字节)。
2.  在当前 `ebp2` 处保存上下文：
    *   `gd[ebp2 : ebp2+3]` = `ret_eip` (3 字节，24位地址)。
    *   `gd[ebp2+3 : ebp2+5]` = `ebp` (2 字节，旧的基址指针)。
3.  更新新基址：`ebp = ebp2`。
4.  跳转：`eip = addr`。

### 2. FUNC size, argc (0x3e)
1.  分配局部空间：`ebp2 = ebp2 + size` (注意：`ebp2` 必须保持全局增长，直到函数调用链返回)。
2.  参数传递：如果有 `argc > 0`：
    *   从 `stk[]` 弹出 `argc` 个值。
    *   将其逆序/顺序拷贝并推送到 `gd[ebp + 5]` 开始的内存中。
    *   *注：LavaX 编译器通常在此存放函数实参。*

### 3. RET (0x3f)
1.  还原 `ebp2`：`ebp2 = ebp`。
2.  从当前 `ebp` 处的 header 恢复状态：
    *   `ebp = *(u16*)&gd[ebp2+3]` (恢复旧 ebp)。
    *   `eip = *(u24*)&gd[ebp2]` (跳转回返回地址)。
3.  返回值通常保留在栈顶 `stk[esp-1]`。

---

## 6. 系统函数 (Syscalls)

操作码在 `0x80 - 0xFF` 范围。执行时需从栈中弹出参数。

| Opcode | 助记符 | 参数 (栈顶优先级最高) | 描述 |
| :--- | :--- | :--- | :--- |
| `0x80` | `putchar` | `char` | 输出字符 |
| `0x81` | `getchar` | - | 获取按键 (阻塞) |
| `0x82` | `printf` | `count, argN, ..., arg1, fmt` | 格式化打印 (fmt 先入栈，count 最后入栈) |
| `0x83` | `strcpy` | `src, dest` | 字符串复制 |
| `0x84` | `strlen` | `str` | 获取长度 |
| `0x87` | `Delay` | `ms` | 延迟 |
| `0x88` | `WriteBlock`| `addr, mode, h, w, y, x` | 位图绘图 |
| `0x89` | `Refresh` | - | 刷新屏幕 (BUF -> VRAM) |
| `0x8a` | `TextOut` | `mode, str, y, x` | 文本输出 |
| `0x8b` | `Block` | `mode, h, w, y, x` | 填充矩形 |
| `0x8c` | `Rectangle`| `mode, h, w, y, x` | 空心矩形 |
| `0x8d` | `Exit` | `ret_val` | 提前退出 |
| `0x8e` | `ClearScreen`| - | 清空绘图缓冲 |
| `0x94` | `Point` | `mode, y, x` | 画点 |
| `0x95` | `GetPoint` | `y, x` | 获取点颜色 |
| `0x96` | `Line` | `mode, y2, x2, y1, x1`| 画线 |
| `0x97` | `Box` | `mode, fill, y2, x2, y1, x1`| 画框 |
| `0x98` | `Circle` | `mode, fill, r, y, x` | 画圆 |
| `0x99` | `Ellipse` | `mode, fill, ry, rx, y, x` | 画椭圆 |
| `0xb8` | `sprintf` | `count, argN, ..., arg1, fmt, dest` | 格式化写入字符串 |
| `0xbc` | `CheckKey` | `key` | 检查按键是否按下 (非阻塞) |
| `0xbd` | `memmove` | `len, src, dest`| 内存移动 |
| `0xd3` | `System` | `sub, ...` | 系统子函数 (如 `0x1f`: GetTickCount) |
| `0xd4` | `Math` | `sub, ...` | 数学子函数 (sin, cos, exp, fadd 等) |
| `0xd5` | `SetPalette`| `addr, count, start` | 设置调色板 |

---

## 7. 程序执行流 (Execution Flow)

### 入口点 (Entry Point)
1.  **全局初始化**: 启动时 `eip` 指向 `0x10`。此处的代码通常负责：
    *   使用 `INIT (0x41)` 初始化全局变量。
    *   设置初始 `ebp` 和 `ebp2` (通常通过 `BASE (0x3c)` 指令，将它们设为全局数据段之后的空闲内存起点)。
2.  **调用 main**: 初始化完成后，通常会有一条 `CALL addr` 指令跳转到 `main` 函数所在的地址。
3.  **退出**: `main` 函数返回后，执行流会回到 `0x10` 后的代码，紧接着通常是 `EXIT (0x40)` 指令。

### 主函数概念 (Main Function)
虽然 GVM 字节码层面没有强制的 `main` 标识，但 LavaX 编译器遵循：
*   所有处于函数定义之外的全局代码块在 `0x10` 顺序执行。
*   用户定义的 `void main()` 或 `int main()` 被编译为一个标准的函数块，其地址由启动代码调用。

---

## 8. 执行生命周期

1.  **加载**: 将 `.lav` 完整读取。
2.  **验证**: 检查 `0x00-0x02` 重置 `LAV` 魔数。
3.  **初始化**:
    *   `eip = 0x10`
    *   `esp = 0`
    *   `ebp = 0`, `ebp2 = 0`
    *   初始化 RAM 为 0。
4.  **循环**:
    *   读取 `op = code[eip++]`
    *   如果是 `op & 0x80`，执行 Syscall。
    *   否则执行基本指令。
    *   遇到 `EXIT (0x40)` 或 `END (0x44)` 退出。
